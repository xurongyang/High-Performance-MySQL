#MySQL架构与历史
###MySQL逻辑架构
MySQL的架构大致可以分为两部分，1.MySQL服务器，2.存储引擎部分。

MySQL服务器负责的部分有：1.处理客户端的网络连接，2.SQL查询解析，分析，优化以及查询缓存，3.所有的内置函数以及跨存储引擎的功能诸如：存储过程，触发器，视图等。

存储引擎负责具体数据的读写，还包括处理事务等。与文件系统类似。

MySQL服务器与存储引擎之间通过几十个底层函数发生交互。

个人认为，这样做的好处是MySQL服务器作为统一的抽象层，屏蔽了底层的实现细节，而任何实现了存储引擎接口的底层存储系统都可以根据需要添加自己想要的功能。跟面向接口编程有相通之处。

###MySQL并发控制
MySQL的数据读写大多情况下都是并发操作，控制并发是必然的。MySQL的方案是读写锁，其实这也是很自然的想法。

锁的粒度分为表锁与行锁，行锁自然比表锁好很多，但在诸如ALTER TABLE等操作的时候会用表锁。MyISAM只有表锁，Innodb则是两者都支持。

###事务

事务的四个特性ACID，1.原子性（atomicity）要么全成功，要么全失败，没有中间状态，2.一致性（consistency）跟原子性有些像，也就是没有中间状态，哪怕执行到一半系统崩溃，也不会出问题。这个是根据事务日志实现的。3.隔离性（isolation）一个事务的修改对其它事务来讲是不可见的。4.持久性（durability）这个没啥好说，事务提交后必须要持久化。

MySQL事务的四个隔离级别：1.read uncommitted，2.read committed，3.repeatable read，4.serializable，顾名思义了，其实1和4基本不可用，很多db的默认级别是2，MySQL是3，2的问题是不可重复读，3的问题是幻读。MySQL通过MVCC算法解决了这个问题。

MVCC算法，通过对每行数据增加两个标志，1.创建版本号，2.删除版本号。在select时，只会选择创建版本号小于小于当前事务版本号的行&删除版本号未定义以及大于当前事务版本号的行。insert，update更新此行版本号为当前事务版本号，删除更新删除版本号。

read committed和repeatable read的MVCC算法是不一样的，read committed始终每行保持最新的数据即可，而repeatable read需要保存每行数据的各个版本来支持可重复读。

MySQL的事务日志，为了保证IO效率，MySQL在修改数据时，会修改在内存中的数据，然后将修改写到事务日志中去。然后再写入磁盘。有两个关键点：1.只写事务日志是顺序写，之前看一个数据对于机械磁盘而言，顺序写是随机写效率的5000倍，所以这样做效率很高。2.避免了每一次都要随机写。两个加起来对效率提升非常有帮助。至于MySQL崩溃了，再根据事务日志恢复便是。

###MySQL的存储引擎

基本是用Innodb了，MyISAM以及用的很少的，MySQL自身存储自己的表结构用的是MyISAM。
