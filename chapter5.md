#创建高性能的索引
###索引基础

+ 索引是存储引擎用于快速找到记录的一种数据结构
+ 索引对于性能非常关键，当表中的数据量越来越大时，索引对性能的影响愈发重要 

###索引的类型
####B-Tree索引
+ 通常来讲，如果没有特别指明的话，通常索引都是指B-Tree索引，使用B-Tree数据结构来存储数据。不过B-Tree是一个代号，不同的存储引擎底层的数据结构不是B-Tree，但是名称依然叫B-Tree。最常用的存储引擎Innodb采用的数据结构实际上是B+Tree
+ 可以使用B-Tree索引的查询类型：全值匹配，匹配最左前缀，匹配列前缀，匹配范围值，精确匹配某一列并范围匹配另外一列，只访问索引的查询
+ 使用B-Tree索引的限制：1.如果不是按照索引的最左列开始查找，则无法使用索引。2.不能跳过索引中的列。3.如果查询中有某一列的范围查询，则其右边所有列都无法使用索引优化。

####哈希索引
+ 哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
+ MySQL中只有memory引擎支持哈希索引，也是memory引擎的默认索引类型
+ Innodb有个特殊的功能：自适应哈希索引，当Innodb发现有些索引值被用的特别频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引。这对于使用者来说是透明的，可以关闭。

其它索引不赘述
###索引的优点
+ 索引大大减少了服务器需要扫描的数据量
+ 索引可以帮助服务器避免排序和临时表
+ 索引可以将随机IO变成顺序IO

###索引的选择性
+ 索引的选择性是不重复的索引值和数据表的记录总数的比值，索引的选择性越高，查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行，唯一性索引的选择性为1，这是最好的索引选择性，性能也是最好的。
+ 对于过长的字符串列，可以使用前缀来创建索引，通过不断增长选择的前缀，计算相应的选择性值来判断当前的前缀是否够用。

###聚簇索引
+ 聚簇索引并不是一种索引类型，而是一种索引方式。
+ 对于Innodb引擎来说，所有的数据都是通过一个B+Tree的数据结构进行存储的。所有的数据都存储在B+Tree的叶子节点，按照主键的顺序依次排序。
+ 对于其它的索引而言，数据也是存储在B+Tree的叶子节点，只不过叶子节点并不存储真实的数据，而是该行数据的主键。
+ 移动聚簇索引的代价很大，会造成“页分裂”，类似于移动ArrayList中的某一项。

###覆盖索引
如果where语句中过滤的列名与创建索引时的列名完全一致，那么该查询只需要查询索引即可，不需要回表查询全部行数据。因为一般情况下，索引比存储的数据要小得多，所以查询速度会快很多。在explain中表现为using index。

###索引与锁
+ Innodb只有在访问行的时候才会对其加锁，而索引能够减少Innodb访问的行数，从而减少锁的数量。