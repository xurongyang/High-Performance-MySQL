#Schema与数据类型优化
###选择正确的数据类型

+ 更小的通常更好。原因非常简单，更小的数据类型占用更少的磁盘空间，更少的内存和更少的CPU周期。但是如果选择的太小，将来要改也是非常费劲。
+ 越简单越好。比如整数比字符串更简单。
+ 尽量避免使用NULL。包含NULL的列使得索引，索引统计和值比较更复杂。可为NULL的列会使用更多的存储空间，Mysql也要做特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节来存储。

###整数类型

+ 整数类型有tinyint，smallint，mediumint，int，mediumint，bigint分别占用1，2，3，4，8个字节的存储空间。
+ 可选择unsigned类型，不为负数，使得正数的上限可以提高一倍。
+ MySQL可以为整数类型指定宽度，比如int(11)但是这基本没意义。

###实数类型
+ 实数类型有float，double和decimal，float为单精度浮点数，double为双精度浮点数，decimal用于存储精确的小数。
+ 三种类型都可以指定精度，比如decimal(18,9)，第一个数字为最多有多少个数字，第二字数字为小数点后可以有多少个数字。
+ float占用4字节，double为8字节，decimal每四个字节存储9个数字，小数点本身占一个字节。decimal最多允许65个数字。
+ 区别：float和double主要用于科学计算，比如3.333333*3 = 10，但是decimal的3.333不是无限循环小数，位数是有限的。

###字符串类型

+ ####VARCHAR类型
	+ 可变字符串，实际占用的空间跟需要的存储的内容一致。
	+ 需要1或者2个字节存储字符串的长度，如果最大长度小于255字节，使用1个字节，否则使用2个字节。
	+ 5.0以后版本会保留末尾空格。

+ ####CHAR类型
	+ 定长字符串，实际占用空间为声明的大小。
	+ 会删除掉末尾空格。
	+ 虽然VARCHAR(10)和VARCHAR(100)存储'hello'的空间开销是一样的，但是MySQL在某些情况下，比如排序时会根据最大的值来分配内存保存内部值，所以最好只分配真正需要的空间。

+ ####BLOB与TEXT类型
	+ 用于存储很大的字符串或者二进制数据。当BLOB或TEXT的值太大时，InnoDB会使用专门的外部存储区域进行存储，在行内存储指向外部存储区域的指针。
	+ 当对BLOB或者TEXT做排序时，只对每个列的最前MAX_SORT_LENGTH字节做排序

+ ####枚举类型
	+ MySQL使用数字-字符串映射关系来处理枚举类型。实际占用空间很少，枚举类型实际上用整数来存储。
	+ 枚举类型的字符串列表是固定的，添加或者删除字符串必须使用ALTER TABLE
	
###日期与时间类型
+ DATETIME和timestamp都可以表示日期和时间，最小的精度为秒。
+ DATETIME可以存储1001到9999年的时间，使用8个字节按照YYYYMMDDHHMMSS整数的方式存储，与时区无关。
+ TIMESTAMP只能表示从1970到2038年，它实际上存储的是从1970年1月1日午夜以来的秒数。FROM_UNIXTIME函数可以把UNIX时间戳转换为日期，UNIX_TIMESTAMP可以把日期转换为UNIX时间戳。
+ TIMESTAMP跟时区有关，相同的时间如果从不同时区读取，时间是不一样的。

###位类型
+ BIT用来存储二进制位。
+ SET用来存储一组BIT。

###选择合适的主键

最好选择自增的整数类型
选择其它类型不好的原因：

+ 插入值会随机写到索引的不同位置，使得INSERT变慢。导致页分裂，磁盘随机访问。
+ SELECT更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方，导致局部性原理失效。

###设计表结构

实际工作中表的设计基本介于范式与反范式之间，总而言之，需要适合业务的情况，减少数据冗余，同时还要兼顾性能。其它一些技巧，不赘述。